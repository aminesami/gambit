;INSERTCODE
;------------------------------------------------------------------------------

(define (run-bench name count ok? run)
  (let loop ((i 0) (result (list 'undefined)))
    (if (< i count)
      (loop (+ i 1) (run))
      result)))

(define (run-benchmark name count ok? run-maker . args)
  (newline)
  (let* ((run (apply run-maker args))
         (result (time (run-bench name count ok? run))))
    (if (not (ok? result))
      (begin
        (display "*** wrong result ***")
        (newline)
        (display "*** got: ")
        (write result)
        (newline))))
  (exit 0))

(define (fatal-error . args)
  (for-each display args)
  (newline)
  (exit 1))

(define (call-with-output-file/truncate filename proc)
  (call-with-output-file filename proc 'truncate))

; Bitwise operations on exact integers.
; From the draft reference implementation of R6RS generic arithmetic.

;(define (bitwise-or i j)
;  (if (and (exact? i)
;           (integer? i)
;           (exact? j)
;           (integer? j))
;      (cond ((or (= i -1) (= j -1))
;             -1)
;            ((= i 0)
;             j)
;            ((= j 0)
;             i)
;            (else
;             (let* ((i0 (if (odd? i) 1 0))
;                    (j0 (if (odd? j) 1 0))
;                    (i1 (- i i0))
;                    (j1 (- j j0))
;                    (i/2 (quotient i1 2))
;                    (j/2 (quotient j1 2))
;                    (hi (* 2 (bitwise-or i/2 j/2)))
;                    (lo (if (= 0 (+ i0 j0)) 0 1)))
;               (+ hi lo))))
;      (error "illegal argument to bitwise-or" i j)))
;
;(define (bitwise-and i j)
;  (if (and (exact? i)
;           (integer? i)
;           (exact? j)
;           (integer? j))
;      (cond ((or (= i 0) (= j 0))
;             0)
;            ((= i -1)
;             j)
;            ((= j -1)
;             i)
;            (else
;             (let* ((i0 (if (odd? i) 1 0))
;                    (j0 (if (odd? j) 1 0))
;                    (i1 (- i i0))
;                    (j1 (- j j0))
;                    (i/2 (quotient i1 2))
;                    (j/2 (quotient j1 2))
;                    (hi (* 2 (bitwise-and i/2 j/2)))
;                    (lo (* i0 j0)))
;               (+ hi lo))))
;      (error "illegal argument to bitwise-and" i j)))
;
;(define (bitwise-not i)
;  (if (and (exact? i)
;           (integer? i))
;      (cond ((= i -1)
;             0)
;            ((= i 0)
;             -1)
;            (else
;             (let* ((i0 (if (odd? i) 1 0))
;                    (i1 (- i i0))
;                    (i/2 (quotient i1 2))
;                    (hi (* 2 (bitwise-not i/2)))
;                    (lo (- 1 i0)))
;               (+ hi lo))))
;      (error "illegal argument to bitwise-not" i j)))
;
;------------------------------------------------------------------------------

; Macros...

(define-syntax def-macro
  (syntax-rules ()
    ((k (name . args) body ...)
     (def-macro name (lambda args body ...)))
    ((k name transformer)
     (define-syntax name
       (lambda (stx)
         (syntax-case stx ()
           ((l . sv)
            (let* ((v (syntax->datum (syntax sv)))
                   (e (apply transformer v)))
              (if (eq? (void) e)
                  (syntax (void))
                  (datum->syntax (syntax l) e))))))))))

(def-macro (arithmetic-shift . lst) `(ash ,@lst))
(def-macro (integer-sqrt . lst) 
           `(call-with-values (lambda () (exact-integer-sqrt ,@lst))
                              (lambda x (car x))))

(if-fixflo-unsafe
(begin

  (define (list->f64vector . lst)
    (let* ((n (* (length lst) 8))
           (v (make-bytevector n 0)))
      (let loop ((i 0) (l lst))
        (if (= i n)
            v
            (begin
              (bytevector-ieee-double-set! v i (car lst))
              (loop (+ 8 i) (cdr lst)))))))

;; Since ChezScheme doesn't have homogenous flonum vectors

(def-macro (FLOATvector-const . lst)   `',(list->f64vector lst))
(def-macro (FLOATvector? x)            `(vector? ,x))
(def-macro (FLOATvector . lst)         `(vector ,@lst))
(def-macro (FLOATmake-vector n . init) `(make-bytevector (* ,n 8) ,@init))
(def-macro (FLOATvector-ref v i)       `(bytevector-ieee-double-ref ,v (* ,i 8)))
(def-macro (FLOATvector-set! v i x)    `(bytevector-ieee-double-set! ,v (* ,i 8) ,x))
(def-macro (FLOATvector-length v)      (/ `(bytevector-length ,v)))

(def-macro (nuc-const . lst)
  `',(list->vector lst))


(def-macro (FLOAT+ . lst) `(fl+ ,@lst))
(def-macro (FLOAT- . lst) `(fl- ,@lst))
(def-macro (FLOAT* . lst) `(fl* ,@lst))
(def-macro (FLOAT/ . lst) `(fl/ ,@lst))
(def-macro (FLOAT= . lst)  `(fl= ,@lst))
(def-macro (FLOAT< . lst)  `(fl< ,@lst))
(def-macro (FLOAT<= . lst) `(fl<= ,@lst))
(def-macro (FLOAT> . lst)  `(fl> ,@lst))
(def-macro (FLOAT>= . lst) `(fl>= ,@lst))
(def-macro (FLOATnegative? . lst) `(flnegative? ,@lst))
(def-macro (FLOATpositive? . lst) `(flpositive? ,@lst))
(def-macro (FLOATzero? . lst)     `(flzero? ,@lst))
(def-macro (FLOATabs . lst) `(flabs ,@lst))
(def-macro (FLOATsin . lst) `(flsin ,@lst))
(def-macro (FLOATcos . lst) `(flcos ,@lst))
(def-macro (FLOATatan . lst) `(flatan ,@lst))
(def-macro (FLOATsqrt . lst) `(flsqrt ,@lst))
(def-macro (FLOATmin . lst) `(flmin ,@lst))
(def-macro (FLOATmax . lst) `(flmax ,@lst))
(def-macro (FLOATround . lst) `(flround ,@lst))
(def-macro (FLOATinexact->exact . lst) `(inexact->exact ,@lst))

;(def-macro (GENERIC+ . lst) `(+ ,@lst))
;(def-macro (GENERIC- . lst) `(- ,@lst))
;(def-macro (GENERIC* . lst) `(* ,@lst))
;(def-macro (GENERIC/ . lst) `(/ ,@lst))
;(def-macro (GENERICquotient . lst)  `(quotient ,@lst))
;(def-macro (GENERICremainder . lst) `(remainder ,@lst))
;(def-macro (GENERICmodulo . lst)    `(modulo ,@lst))
;(def-macro (GENERIC= . lst)  `(= ,@lst))
;(def-macro (GENERIC< . lst)  `(< ,@lst))
;(def-macro (GENERIC<= . lst) `(<= ,@lst))
;(def-macro (GENERIC> . lst)  `(> ,@lst))
;(def-macro (GENERIC>= . lst) `(>= ,@lst))
;(def-macro (GENERICexpt . lst) `(expt ,@lst))

(define (GENERIC+ x y) (+ x y))
(define (GENERIC- x y) (- x y))
(define (GENERIC* x y) (* x y))
(define (GENERIC/ x y) (/ x y))
(define (GENERICquotient x y) (quotient x y))
(define (GENERICremainder x y) (remainder x y))
(define (GENERICmodulo x y) (modulo x y))
(define (GENERIC= x y) (= x y))
(define (GENERIC< x y) (< x y))
(define (GENERIC<= x y) (<= x y))
(define (GENERIC> x y) (> x y))
(define (GENERIC>= x y) (>= x y))
(define (GENERICexpt x y) (expt x y))

(def-macro (+ . lst) `(fx+ ,@lst))
(def-macro (- . lst) `(fx- ,@lst))
(def-macro (* . lst) `(fx* ,@lst))
(def-macro (quotient . lst) `(fxquotient ,@lst))
(def-macro (modulo . lst) `(fxmodulo ,@lst))
(def-macro (remainder . lst) `(fxremainder ,@lst))
(def-macro (= . lst)  `(fx= ,@lst))
(def-macro (< . lst)  `(fx< ,@lst))
(def-macro (<= . lst) `(fx<= ,@lst))
(def-macro (> . lst)  `(fx> ,@lst))
(def-macro (>= . lst) `(fx>= ,@lst))
(def-macro (negative? . lst) `(fxnegative? ,@lst))
(def-macro (positive? . lst) `(fxpositive? ,@lst))
(def-macro (zero? . lst) `(fxzero? ,@lst))
(def-macro (odd? . lst) `(fxodd? ,@lst))
(def-macro (even? . lst) `(fxeven? ,@lst))
(def-macro (bitwise-or . lst) `(fxior ,@lst))
(def-macro (bitwise-and . lst) `(fxand ,@lst))
(def-macro (bitwise-not . lst) `(fxnot ,@lst))
)

(begin

; Specialize fixnum and flonum arithmetic.

;; Since ChezScheme doesn't have homogenous flonum vectors

(def-macro (FLOATvector-const . lst)   `',(list->vector lst))
(def-macro (FLOATvector? x)            `(vector? ,x))
(def-macro (FLOATvector . lst)         `(vector ,@lst))
(def-macro (FLOATmake-vector n . init) `(make-vector ,n ,@init))
(def-macro (FLOATvector-ref v i)       `(vector-ref ,v ,i))
(def-macro (FLOATvector-set! v i x)    `(vector-set! ,v ,i ,x))
(def-macro (FLOATvector-length v)      `(vector-length ,v))

(def-macro (nuc-const . lst)
  `',(list->vector lst))


(def-macro (FLOAT+ . lst) `(fl+ ,@lst))
(def-macro (FLOAT- . lst) `(fl- ,@lst))
(def-macro (FLOAT* . lst) `(fl* ,@lst))
(def-macro (FLOAT/ . lst) `(fl/ ,@lst))
(def-macro (FLOAT= . lst)  `(fl= ,@lst))
(def-macro (FLOAT< . lst)  `(fl< ,@lst))
(def-macro (FLOAT<= . lst) `(fl<= ,@lst))
(def-macro (FLOAT> . lst)  `(fl> ,@lst))
(def-macro (FLOAT>= . lst) `(fl>= ,@lst))
(def-macro (FLOATnegative? . lst) `(flnegative? ,@lst))
(def-macro (FLOATpositive? . lst) `(flpositive? ,@lst))
(def-macro (FLOATzero? . lst)     `(flzero? ,@lst))
(def-macro (FLOATabs . lst) `(flabs ,@lst))
(def-macro (FLOATsin . lst) `(flsin ,@lst))
(def-macro (FLOATcos . lst) `(flcos ,@lst))
(def-macro (FLOATatan . lst) `(flatan ,@lst))
(def-macro (FLOATsqrt . lst) `(flsqrt ,@lst))
(def-macro (FLOATmin . lst) `(flmin ,@lst))
(def-macro (FLOATmax . lst) `(flmax ,@lst))
(def-macro (FLOATround . lst) `(flround ,@lst))
(def-macro (FLOATinexact->exact . lst) `(inexact->exact ,@lst))

;(def-macro (GENERIC+ . lst) `(+ ,@lst))
;(def-macro (GENERIC- . lst) `(- ,@lst))
;(def-macro (GENERIC* . lst) `(* ,@lst))
;(def-macro (GENERIC/ . lst) `(/ ,@lst))
;(def-macro (GENERICquotient . lst)  `(quotient ,@lst))
;(def-macro (GENERICremainder . lst) `(remainder ,@lst))
;(def-macro (GENERICmodulo . lst)    `(modulo ,@lst))
;(def-macro (GENERIC= . lst)  `(= ,@lst))
;(def-macro (GENERIC< . lst)  `(< ,@lst))
;(def-macro (GENERIC<= . lst) `(<= ,@lst))
;(def-macro (GENERIC> . lst)  `(> ,@lst))
;(def-macro (GENERIC>= . lst) `(>= ,@lst))
;(def-macro (GENERICexpt . lst) `(expt ,@lst))

(define (GENERIC+ x y) (+ x y))
(define (GENERIC- x y) (- x y))
(define (GENERIC* x y) (* x y))
(define (GENERIC/ x y) (/ x y))
(define (GENERICquotient x y) (quotient x y))
(define (GENERICremainder x y) (remainder x y))
(define (GENERICmodulo x y) (modulo x y))
(define (GENERIC= x y) (= x y))
(define (GENERIC< x y) (< x y))
(define (GENERIC<= x y) (<= x y))
(define (GENERIC> x y) (> x y))
(define (GENERIC>= x y) (>= x y))
(define (GENERICexpt x y) (expt x y))

(def-macro (+ . lst) `(fx+ ,@lst))
(def-macro (- . lst) `(fx- ,@lst))
(def-macro (* . lst) `(fx* ,@lst))
(def-macro (quotient . lst) `(fxquotient ,@lst))
(def-macro (modulo . lst) `(fxmodulo ,@lst))
(def-macro (remainder . lst) `(fxremainder ,@lst))
(def-macro (= . lst)  `(fx= ,@lst))
(def-macro (< . lst)  `(fx< ,@lst))
(def-macro (<= . lst) `(fx<= ,@lst))
(def-macro (> . lst)  `(fx> ,@lst))
(def-macro (>= . lst) `(fx>= ,@lst))
(def-macro (negative? . lst) `(fxnegative? ,@lst))
(def-macro (positive? . lst) `(fxpositive? ,@lst))
(def-macro (zero? . lst) `(fxzero? ,@lst))
(def-macro (odd? . lst) `(fxodd? ,@lst))
(def-macro (even? . lst) `(fxeven? ,@lst))
(def-macro (bitwise-or . lst) `(fxior ,@lst))
(def-macro (bitwise-and . lst) `(fxand ,@lst))
(def-macro (bitwise-not . lst) `(fxnot ,@lst))

; FIXME

;(define-syntax bitwise-or
;  (syntax-rules ()
;    ((bitwise-or x y) (fxior x y))))

;(define-syntax bitwise-and
;  (syntax-rules ()
;    ((bitwise-and x y) (fxand x y))))

;(define-syntax bitwise-not
;  (syntax-rules ()
;    ((bitwise-not x) (fxnot x))))
)

(begin

; Don't specialize fixnum and flonum arithmetic.

(def-macro (FLOATvector-const . lst)   `',(list->vector lst))
(def-macro (FLOATvector? x)            `(vector? ,x))
(def-macro (FLOATvector . lst)         `(vector ,@lst))
(def-macro (FLOATmake-vector n . init) `(make-vector ,n ,@init))
(def-macro (FLOATvector-ref v i)       `(vector-ref ,v ,i))
(def-macro (FLOATvector-set! v i x)    `(vector-set! ,v ,i ,x))
(def-macro (FLOATvector-length v)      `(vector-length ,v))

(def-macro (nuc-const . lst)
  `',(list->vector lst))

(def-macro (FLOAT+ . lst) `(+ ,@lst))
(def-macro (FLOAT- . lst) `(- ,@lst))
(def-macro (FLOAT* . lst) `(* ,@lst))
(def-macro (FLOAT/ . lst) `(/ ,@lst))
(def-macro (FLOAT= . lst)  `(= ,@lst))
(def-macro (FLOAT< . lst)  `(< ,@lst))
(def-macro (FLOAT<= . lst) `(<= ,@lst))
(def-macro (FLOAT> . lst)  `(> ,@lst))
(def-macro (FLOAT>= . lst) `(>= ,@lst))
(def-macro (FLOATnegative? . lst) `(negative? ,@lst))
(def-macro (FLOATpositive? . lst) `(positive? ,@lst))
(def-macro (FLOATzero? . lst)     `(zero? ,@lst))
(def-macro (FLOATabs . lst) `(abs ,@lst))
(def-macro (FLOATsin . lst) `(sin ,@lst))
(def-macro (FLOATcos . lst) `(cos ,@lst))
(def-macro (FLOATatan . lst) `(atan ,@lst))
(def-macro (FLOATsqrt . lst) `(sqrt ,@lst))
(def-macro (FLOATmin . lst) `(min ,@lst))
(def-macro (FLOATmax . lst) `(max ,@lst))
(def-macro (FLOATround . lst) `(round ,@lst))
(def-macro (FLOATinexact->exact . lst) `(inexact->exact ,@lst))

(def-macro (GENERIC+ . lst) `(+ ,@lst))
(def-macro (GENERIC- . lst) `(- ,@lst))
(def-macro (GENERIC* . lst) `(* ,@lst))
(def-macro (GENERIC/ . lst) `(/ ,@lst))
(def-macro (GENERICquotient . lst)  `(quotient ,@lst))
(def-macro (GENERICremainder . lst) `(remainder ,@lst))
(def-macro (GENERICmodulo . lst)    `(modulo ,@lst))
(def-macro (GENERIC= . lst)  `(= ,@lst))
(def-macro (GENERIC< . lst)  `(< ,@lst))
(def-macro (GENERIC<= . lst) `(<= ,@lst))
(def-macro (GENERIC> . lst)  `(> ,@lst))
(def-macro (GENERIC>= . lst) `(>= ,@lst))
(def-macro (GENERICexpt . lst) `(expt ,@lst))
)
)

;------------------------------------------------------------------------------
